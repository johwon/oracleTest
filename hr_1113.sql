--Transaction
DROP TABLE DEPT02;

--테이블 복사
CREATE TABLE DEPT02
AS
SELECT * FROM DEPARTMENTS
WHERE 1=0;

--트랜잭션 시작(롤백위치)
--내용 복사
INSERT INTO DEPT02 SELECT * FROM DEPARTMENTS;

SELECT * FROM DEPT02;

SAVEPOINT C1;

DELETE FROM DEPT02 WHERE DEPARTMENT_ID = 90;

ROLLBACK TO C1;


--VIEW 생성하기(테이블생성 복사하기 똑같음
CREATE VIEW VIEW_EMP01
AS 
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID FROM EMP_COPY
WHERE DEPARTMENT_ID = 10;

SELECT * FROM VIEW_EMP01;

--EMPLOYEES 복사하기 EMP_COPY
CREATE TABLE EMP_COPY
AS
SELECT * FROM EMPLOYEES;

SELECT * FROM EMP_COPY;

--뷰를 제거하기
DROP VIEW VIEW_EMP01;

--뷰 생성
CREATE VIEW VIEW_EMP01
AS 
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID FROM EMP_COPY
WHERE DEPARTMENT_ID = 10;

SELECT * FROM VIEW_EMP01;
SELECT * FROM EMP_COPY WHERE EMPLOYEE_ID=200;

--VIEW 수정하기 -> 원본도 같이 수정됨!!
UPDATE VIEW_EMP01 SET SALARY = 4500 WHERE EMPLOYEE_ID=200;

--DATA DICTIONARY
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM USER_VIEWS;
SELECT * FROM USER_INDEXES;

--가상VIEW에 컬럼 4개 INSERT 
--원본테이블 컬럼 10개, 그중에 NOT NULL인데 가상테이블에 포함되어 있지 않으면 입력 안됨
SELECT * FROM VIEW_EMP01;
INSERT INTO VIEW_EMP01 VALUES(500,'KIM',9999,99);

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP_COPY';

--뷰 생성
CREATE VIEW VIEW_EMP02
AS 
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID 
FROM EMP_COPY
WHERE DEPARTMENT_ID = 10;

SELECT * FROM VIEW_EMP02;
INSERT INTO VIEW_EMP02 VALUES(1000,'AAA','BBB','ABC',TO_DATE('2020-1-1', 'YY/MM/DD'),'IT_DEV');

--뷰3 생성
CREATE VIEW VIEW_EMP03
AS 
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID 
FROM EMP_COPY;

SELECT * FROM VIEW_EMP03;
INSERT INTO VIEW_EMP03 VALUES(2000,'AAA','BBB','ABC',TO_DATE('2020-1-1', 'YY/MM/DD'),'IT_DEV');
SELECT * FROM EMP_COPY;

--가상뷰에서 삭제 진행
DELETE FROM VIEW_EMP03 WHERE EMPLOYEE_ID=2000;

--복합뷰 생성하기(EMPLOYEES, DEPARTMENTS 두개의 테이블을 조인해서 새로운 가상테이블을 만들기)
CREATE OR REPLACE VIEW VIEW_EMP_DEP
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D USING(DEPARTMENT_ID) ORDER BY DEPARTMENT_ID
WITH READ ONLY;

SELECT * FROM VIEW_EMP_DEP;
SELECT DISTINCT DEPARTMENT_ID, DEPARTMENT_NAME FROM VIEW_EMP_DEP;
--부서명IT의 평균연봉, 최고값, 최저값
SELECT AVG(SALARY), MAX(SALARY), MIN(SALARY) FROM VIEW_EMP_DEP WHERE DEPARTMENT_NAME='IT';
SELECT DEPARTMENT_NAME, ROUND(AVG(SALARY)), MAX(SALARY), MIN(SALARY) FROM VIEW_EMP_DEP GROUP BY DEPARTMENT_NAME;

--VIEW FORCE
CREATE OR REPLACE FORCE VIEW VIEW_FORCE
AS
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, DEPARTMENT_ID
FROM EMP20;

DESC VIEW_FORCE;
SELECT * FROM VIEW_FORCE;


--ROWNUM
SELECT * FROM EMPLOYEES;
SELECT ROWNUM, DEPARTMENT_ID, FIRST_NAME FROM EMPLOYEES WHERE DEPARTMENT_ID = 100
ORDER BY FIRST_NAME DESC;
SELECT ROWNUM, DEPARTMENT_ID, FIRST_NAME FROM EMPLOYEES WHERE DEPARTMENT_ID = 100;

--ROWNUM 정렬해서 순서가 흐트러진것을 다시 순서적으로 보여주고싶을때
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE DESC;

CREATE OR REPLACE VIEW VIEW_HIREDATE
AS
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE DESC;

SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM VIEW_HIREDATE;
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM VIEW_HIREDATE WHERE ROWNUM = 4;

--인라인뷰
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE 
FROM (SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE DESC)
WHERE ROWNUM <=4;







