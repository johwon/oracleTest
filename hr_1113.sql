--Transaction
DROP TABLE DEPT02;

--테이블 복사
CREATE TABLE DEPT02
AS
SELECT * FROM DEPARTMENTS
WHERE 1=0;

--트랜잭션 시작(롤백위치)
--내용 복사
INSERT INTO DEPT02 SELECT * FROM DEPARTMENTS;

SELECT * FROM DEPT02;

SAVEPOINT C1;

DELETE FROM DEPT02 WHERE DEPARTMENT_ID = 90;

ROLLBACK TO C1;


--VIEW 생성하기(테이블생성 복사하기 똑같음
CREATE VIEW VIEW_EMP01
AS 
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID FROM EMP_COPY
WHERE DEPARTMENT_ID = 10;

SELECT * FROM VIEW_EMP01;

--EMPLOYEES 복사하기 EMP_COPY
CREATE TABLE EMP_COPY
AS
SELECT * FROM EMPLOYEES;

SELECT * FROM EMP_COPY;

--뷰를 제거하기
DROP VIEW VIEW_EMP01;

--뷰 생성
CREATE VIEW VIEW_EMP01
AS 
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID FROM EMP_COPY
WHERE DEPARTMENT_ID = 10;

SELECT * FROM VIEW_EMP01;
SELECT * FROM EMP_COPY WHERE EMPLOYEE_ID=200;

--VIEW 수정하기 -> 원본도 같이 수정됨!!
UPDATE VIEW_EMP01 SET SALARY = 4500 WHERE EMPLOYEE_ID=200;

--DATA DICTIONARY
SELECT * FROM USER_TABLES;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM USER_CONS_COLUMNS WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM USER_VIEWS;
SELECT * FROM USER_INDEXES;

--가상VIEW에 컬럼 4개 INSERT 
--원본테이블 컬럼 10개, 그중에 NOT NULL인데 가상테이블에 포함되어 있지 않으면 입력 안됨
SELECT * FROM VIEW_EMP01;
INSERT INTO VIEW_EMP01 VALUES(500,'KIM',9999,99);

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = 'EMP_COPY';

--뷰 생성
CREATE VIEW VIEW_EMP02
AS 
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID 
FROM EMP_COPY
WHERE DEPARTMENT_ID = 10;

SELECT * FROM VIEW_EMP02;
INSERT INTO VIEW_EMP02 VALUES(1000,'AAA','BBB','ABC',TO_DATE('2020-1-1', 'YY/MM/DD'),'IT_DEV');

--뷰3 생성
CREATE VIEW VIEW_EMP03
AS 
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID 
FROM EMP_COPY;

SELECT * FROM VIEW_EMP03;
INSERT INTO VIEW_EMP03 VALUES(2000,'AAA','BBB','ABC',TO_DATE('2020-1-1', 'YY/MM/DD'),'IT_DEV');
SELECT * FROM EMP_COPY;

--가상뷰에서 삭제 진행
DELETE FROM VIEW_EMP03 WHERE EMPLOYEE_ID=2000;

--복합뷰 생성하기(EMPLOYEES, DEPARTMENTS 두개의 테이블을 조인해서 새로운 가상테이블을 만들기)
CREATE OR REPLACE VIEW VIEW_EMP_DEP
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID, DEPARTMENT_NAME, LOCATION_ID
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D USING(DEPARTMENT_ID) ORDER BY DEPARTMENT_ID
WITH READ ONLY;

SELECT * FROM VIEW_EMP_DEP;
SELECT DISTINCT DEPARTMENT_ID, DEPARTMENT_NAME FROM VIEW_EMP_DEP;
--부서명IT의 평균연봉, 최고값, 최저값
SELECT AVG(SALARY), MAX(SALARY), MIN(SALARY) FROM VIEW_EMP_DEP WHERE DEPARTMENT_NAME='IT';
SELECT DEPARTMENT_NAME, ROUND(AVG(SALARY)), MAX(SALARY), MIN(SALARY) FROM VIEW_EMP_DEP GROUP BY DEPARTMENT_NAME;

--VIEW FORCE
CREATE OR REPLACE FORCE VIEW VIEW_FORCE
AS
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, DEPARTMENT_ID
FROM EMP20;

DESC VIEW_FORCE;
SELECT * FROM VIEW_FORCE;


--ROWNUM
SELECT * FROM EMPLOYEES;
SELECT ROWNUM, DEPARTMENT_ID, FIRST_NAME FROM EMPLOYEES WHERE DEPARTMENT_ID = 100
ORDER BY FIRST_NAME DESC;
SELECT ROWNUM, DEPARTMENT_ID, FIRST_NAME FROM EMPLOYEES WHERE DEPARTMENT_ID = 100;

--ROWNUM 정렬해서 순서가 흐트러진것을 다시 순서적으로 보여주고싶을때
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE DESC;

CREATE OR REPLACE VIEW VIEW_HIREDATE
AS
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE DESC;

SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM VIEW_HIREDATE;
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM VIEW_HIREDATE WHERE ROWNUM = 4;

--인라인뷰
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE 
FROM (SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES ORDER BY HIRE_DATE DESC)
WHERE ROWNUM <=4;

--시퀀스 생성
CREATE SEQUENCE EMO_SEQ
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 100000
NOCYCLE
CACHE 2;

SELECT * FROM user_sequences;

--EMPLOYEES 구조만 복사
DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE FROM EMPLOYEES WHERE 1=0;

SELECT * FROM EMP01;
--EMP_SEQ.NEXTVAL 입력하기
INSERT INTO EMP01 VALUES(EMO_SEQ.NEXTVAL,'KIM',SYSDATE);

--EMP_SEQ.CURRVAL
SELECT EMO_SEQ.CURRVAL FROM DUAL;


--SEQUENCE DEPT_SEQ 생성하기, 시작값 10, 증가치 10, 결과치 30
CREATE SEQUENCE DEPT_SEQ
START WITH 10
INCREMENT BY 10
MAXVALUE 30;

SELECT * FROM USER_SEQUENCES;

--DEPT01 테이블 구조만 복사
DROP TABLE DEPT02;
CREATE TABLE DEPT02
AS
SELECT * FROM DEPARTMENTS WHERE 1=0;
SELECT * FROM DEPARTMENTS;
INSERT INTO DEPT02 VALUES(DEPT_SEQ.NEXTVAL, '인사과', 1, 1);
INSERT INTO DEPT02 VALUES(DEPT_SEQ.NEXTVAL, '총무과', 2, 2);
INSERT INTO DEPT02 VALUES(DEPT_SEQ.NEXTVAL, '총무과', 3, 3);
INSERT INTO DEPT02 VALUES(DEPT_SEQ.NEXTVAL, '총무과', 4, 4);
SELECT * FROM DEPT02;

--SEQUENCE 수정하기
ALTER SEQUENCE DEPT_SEQ 
MAXVALUE 100;
SELECT * FROM USER_SEQUENCES;

--SEQUENCE 삭제
DROP SEQUENCE DEPT_SEQ;

--데이터 딕셔너리에서 인덱스 확인하기
SELECT * FROM USER_INDEXES WHERE TABLE_NAME = 'EMPLOYEES';
SELECT * FROM user_ind_columns;

SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID=100;

DROP TABLE EMP10;
CREATE TABLE EMP10
AS
SELECT * FROM EMPLOYEES;
SELECT * FROM EMP10 WHERE EMPLOYEE_ID=100;

--인덱스 생성하기
SELECT * FROM USER_IND_COLUMNS WHERE TABLE_NAME = 'EMP10';

CREATE UNIQUE INDEX EMP10_EMPLOYEE_ID_IX ON EMP10(EMPLOYEE_ID);

--인덱스 삭제하기
DROP INDEX EMP10_EMPLOYEE_ID_IX;






--1.사원 번호와 사원명과 부서명과 부서의 위치를 출력하는 뷰(VIEW_LOC)를 작성하라
DROP VIEW VIEW_LOC;
CREATE VIEW VIEW_LOC
AS
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_NAME, LOCATION_ID
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

SELECT * FROM VIEW_LOC;

--2. 30번 부서 소속 사원의 이름과 입사일과 부서명을 출력하는 뷰(VIEW_DEPT30)를 작성하라
DROP VIEW VIEW_DEPT30;
CREATE VIEW VIEW_DEPT30
AS
SELECT FIRST_NAME, HIRE_DATE, DEPARTMENT_NAME
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.DEPARTMENT_ID = 30;

SELECT * FROM VIEW_DEPT30;

--3.부서별 최대 급여 정보를 가지는 뷰(VIEW_DEPT_MAXSAL)를 생성하라
CREATE VIEW VIEW_DEPT_MAXSAL
AS
SELECT MAX(SALARY) AS MAXSAL
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

SELECT * FROM VIEW_DEPT_MAXSAL;

--4.급여를 많이 받는 순서대로 3명만 출력하는 뷰(VIEW_SAL_TOP3)와 인라인 뷰로 작성하라
--INSERT기준으로 ROWNUM 지정되므로 VIEW로 내가 원하는 정렬을 만들고 SELECT에서 ROWNUM 활용
--뷰
CREATE VIEW VIEW_SAL_TOP3
AS
SELECT FIRST_NAME, SALARY
FROM EMPLOYEES
ORDER BY SALARY DESC;

SELECT ROWNUM, FIRST_NAME, SALARY FROM VIEW_SAL_TOP3 WHERE ROWNUM <=3;

--인라인VIEW
SELECT ROWNUM, FIRST_NAME, SALARY
FROM (SELECT * FROM EMPLOYEES ORDER BY SALARY DESC)
WHERE ROWNUM <= 3;