--TRIGGER 테스트
--EMP01 생성하고 입력이 될때마다 입력값을 출력해주는 트리거 생성
DROP TABLE EMP01;
CREATE TABLE EMP01(
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(20),
    JOB_ID VARCHAR2(50)
);

CREATE OR REPLACE TRIGGER EMP01_TRIGGER
    AFTER INSERT ON EMP01
    FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE(:NEW.EMPNO||','||:NEW.ENAME||'신입사원이 입사했습니다.');
END;
/

--INSERT하기
INSERT INTO EMP01 VALUES(
    (SELECT NVL(MAX(EMPNO),0)+1 FROM EMP01),
    DBMS_RANDOM.STRING('U',4),
    'IT_DEV'
);
SELECT * FROM EMP01;
SELECT * FROM SAL01;

--SAL01 테이블 생성
--EMP01에 입력되면 입력된 데이터를 SAL01에 재입력
CREATE TABLE SAL01(
    SALNO NUMBER(4),
    SAL NUMBER,
    EMPNO NUMBER(4)
);
ALTER TABLE SAL01 ADD CONSTRAINTS SAL01_PK_SALNO PRIMARY KEY(SALNO);
ALTER TABLE SAL01 ADD CONSTRAINTS SAL01_FK_EMPNO FOREIGN KEY(EMPNO) REFERENCES EMP01(EMPNO);

DESC SAL01;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME ='SAL01';

CREATE SEQUENCE SAL01_SEQ
START WITH 1
INCREMENT BY 1
MINVALUE 1
MAXVALUE 100000
NOCYCLE
CACHE 2;

CREATE OR REPLACE TRIGGER EMP01_TRIGGER2
AFTER INSERT ON EMP01
FOR EACH ROW
BEGIN
    INSERT INTO SAL01 VALUES(SAL01_SEQ.NEXTVAL, 100000, :NEW.EMPNO);
    DBMS_OUTPUT.PUT_LINE(:NEW.EMPNO||'번호 사원이 SAL01에 잘 들어왔습니다.');
END;
/

--EMP01에서 사원의 정보를 제거했을때 SAL01에서도 해당되는 사원 정보 삭제하는 트리거
CREATE OR REPLACE TRIGGER EMP01_TRIGGER3
    AFTER DELETE ON EMP01
    FOR EACH ROW
BEGIN
    DELETE FROM SAL01 WHERE EMPNO = :OLD.EMPNO;
    DBMS_OUTPUT.PUT_LINE(:OLD.EMPNO||'번 사원의 정보가 SAL01에서 삭제되었습니다.');
END;
/
SELECT * FROM EMP01;
SELECT * FROM SAL01;
DELETE FROM EMP01 WHERE EMPNO = 3;

--입고 트리거 작성하기
--재고 테이블 생성
DROP TABLE PRODUCT;
CREATE TABLE PRODUCT(
    PCODE CHAR(6),
    PNAME VARCHAR2(12) NOT NULL,
    PCOMPANY VARCHAR2(12),
    PPRICE NUMBER(9),
    STOCK NUMBER DEFAULT 0
);
ALTER TABLE PRODUCT ADD CONSTRAINTS PRODUCT_PK_PCODE PRIMARY KEY(PCODE);

--입고테이블 생성
CREATE TABLE RECEIVING(
    RNO NUMBER(6),
    PCODE CHAR(6),
    RDATE DATE DEFAULT SYSDATE,
    RQTY NUMBER(6),
    RPRICE NUMBER(8),
    RAMOUNT NUMBER(8)
);
ALTER TABLE RECEIVING ADD CONSTRAINTS RECEIVING_PK_RNO PRIMARY KEY(RNO);
ALTER TABLE RECEIVING ADD CONSTRAINTS RECEIVING_FK_PCODE FOREIGN KEY(PCODE) REFERENCES PRODUCT(PCODE);

INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY, PPRICE) VALUES('A00001','세탁기','LG',1500000);
INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY, PPRICE) VALUES('A00002','컴퓨터','LG',1000000);
INSERT INTO PRODUCT(PCODE, PNAME, PCOMPANY, PPRICE) VALUES('A00003','냉장고','삼성',4500000);
SELECT * FROM PRODUCT;

UPDATE PRODUCT SET STOCK=0; 

-- 입고 테이블에 상품이 입력되면 입고 수량을 상품 테이블의 재고 수량에 추가하는 트리거 작성. 
CREATE OR REPLACE TRIGGER PRODUCT_TRIGGER
    AFTER INSERT ON RECEIVING
    FOR EACH ROW
BEGIN
    UPDATE PRODUCT SET STOCK=(STOCK+:NEW.RQTY) WHERE PCODE=:NEW.PCODE;
    DBMS_OUTPUT.PUT_LINE(:NEW.PCODE||'의 재고가 '||:NEW.RQTY||'개 증가하였습니다.');
END;
/

--입고테이블 상품 추가
INSERT INTO RECEIVING(RNO, PCODE, RQTY) 
VALUES((SELECT NVL(MAX(RNO),0)+1 FROM RECEIVING), 'A00003', 10);

--확인
SELECT * FROM PRODUCT;
SELECT * FROM RECEIVING;

--갱신 트리거 (입고수량을 30 추가, 10 추가 진행했을때 마지막 10개를 5개로 업데이트했을때,
--PRODUCT 재고수량도 업데이트하는 트리거)
CREATE OR REPLACE TRIGGER RECEIVING_TRIGGER
    AFTER UPDATE ON RECEIVING
    FOR EACH ROW
BEGIN
    UPDATE PRODUCT SET STOCK = STOCK+(-:OLD.RQTY+:NEW.RQTY) WHERE PCODE = :NEW.PCODE;
END;
/
UPDATE RECEIVING SET RQTY = 20, RPRICE = 1000000, RAMOUNT=1000000 WHERE RNO=5;

SELECT * FROM RECEIVING;
SELECT * FROM PRODUCT;



--삭제트리거(입고테이블에서 삭제되면 상품테이블 재고에서 삭제된 수량을 빼줌)
CREATE OR REPLACE TRIGGER RECEIVING_DEL_TRIGGER
    AFTER DELETE ON RECEIVING
    FOR EACH ROW
BEGIN
    UPDATE PRODUCT SET STOCK = STOCK - :OLD.RQTY WHERE PCODE = :OLD.PCODE;
END;
/

SELECT * FROM RECEIVING;
SELECT * FROM PRODUCT;
DELETE FROM RECEIVING WHERE RNO = 5;

--FUNCTION 부서번호를 입력하면 부서명을 리턴해주는 함수.
--부서번호가 존재하지 않으면 '해당부서없음' 값으로 리턴
CREATE OR REPLACE FUNCTION GET_DEP_NAME_FUNC(VDEPARTMENT_ID EMPLOYEES.DEPARTMENT_ID%TYPE) 
RETURN VARCHAR2
IS
    VDEPARTMENT_NAME VARCHAR2(100);
    VCOUNT NUMBER := 0;
BEGIN
    --해당 부서의 카운트를 체크
    SELECT COUNT(*) INTO VCOUNT FROM EMPLOYEES WHERE DEPARTMENT_ID = VDEPARTMENT_ID;
    IF(VCOUNT=0) THEN
        VDEPARTMENT_NAME := '해당부서없음';
    ELSE
       SELECT DEPARTMENT_NAME INTO VDEPARTMENT_NAME FROM DEPARTMENTS WHERE DEPARTMENT_ID = VDEPARTMENT_ID; 
    END IF;
    RETURN VDEPARTMENT_NAME;
END;
/

--함수를 이용해서 부서번호를 매개변수 등록하고 부서명 구하는 기능 사용
SELECT DEPARTMENT_NAME FROM DEPARTMENTS WHERE DEPARTMENT_ID = 100;
SELECT FIRST_NAME,SALARY,GET_DEP_NAME_FUNC(DEPARTMENT_ID) AS "DEPARTMENT_NAME"
FROM EMPLOYEES WHERE FIRST_NAME='Lex';

VARIABLE VNAME VARCHAR2;
EXECUTE : VNAME := GET_DEP_NAME_FUNC(90);
PRINT VNAME;













